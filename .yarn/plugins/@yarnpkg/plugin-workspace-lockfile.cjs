/* eslint-disable */
//prettier-ignore
module.exports = {
  name: "@yarnpkg/plugin-workspace-lockfile",
  factory: function (require) {
    var plugin=(()=>{var g=Object.defineProperty;var R=Object.getOwnPropertyDescriptor;var A=Object.getOwnPropertyNames;var v=Object.prototype.hasOwnProperty;var w=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(o,c)=>(typeof require<"u"?require:o)[c]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')});var C=(e,o)=>{for(var c in o)g(e,c,{get:o[c],enumerable:!0})},P=(e,o,c,f)=>{if(o&&typeof o=="object"||typeof o=="function")for(let n of A(o))!v.call(e,n)&&n!==c&&g(e,n,{get:()=>o[n],enumerable:!(f=R(o,n))||f.enumerable});return e};var S=e=>P(g({},"__esModule",{value:!0}),e);var T={};C(T,{default:()=>O});var r=w("@yarnpkg/core"),E=w("@yarnpkg/cli"),m=w("@yarnpkg/fslib");var a=w("@yarnpkg/core"),u=w("@yarnpkg/fslib"),k=w("@yarnpkg/parsers"),D="<<<<<<<";async function h(e,o,c){if(!e.projectCwd)return!1;let f=u.ppath.join(e.projectCwd,o);if(!await u.xfs.existsPromise(f)||!(await u.xfs.readFilePromise(f,"utf8")).includes(D))return!1;if(c)throw new a.ReportError(a.MessageName.AUTOMERGE_IMMUTABLE,"Cannot autofix a lockfile when running an immutable install");let p=await a.execUtils.execvp("git",["rev-parse","MERGE_HEAD","HEAD"],{cwd:e.projectCwd});if(p.code!==0&&(p=await a.execUtils.execvp("git",["rev-parse","REBASE_HEAD","HEAD"],{cwd:e.projectCwd})),p.code!==0&&(p=await a.execUtils.execvp("git",["rev-parse","CHERRY_PICK_HEAD","HEAD"],{cwd:e.projectCwd})),p.code!==0)throw new a.ReportError(a.MessageName.AUTOMERGE_GIT_ERROR,"Git returned an error when trying to find the commits pertaining to the conflict");let s=await Promise.all(p.stdout.trim().split(/\n/).map(async t=>{let i=await a.execUtils.execvp("git",["show",`${t}:./${o}`],{cwd:e.projectCwd});if(i.code!==0)throw new a.ReportError(a.MessageName.AUTOMERGE_GIT_ERROR,`Git returned an error when trying to access the lockfile content in ${t}`);try{return(0,k.parseSyml)(i.stdout)}catch{throw new a.ReportError(a.MessageName.AUTOMERGE_FAILED_TO_PARSE,"A variant of the conflicting lockfile failed to parse")}}));s=s.filter(t=>!!t.__metadata);for(let t of s){if(t.__metadata.version<7)for(let i of Object.keys(t)){if(i==="__metadata")continue;let d=a.structUtils.parseDescriptor(i,!0),_=e.normalizeDependency(d),y=a.structUtils.stringifyDescriptor(_);y!==i&&(t[y]=t[i],delete t[i])}for(let i of Object.keys(t)){if(i==="__metadata")continue;let d=t[i].checksum;typeof d=="string"&&d.includes("/")||(t[i].checksum=`${t.__metadata.cacheKey}/${d}`)}}let l=Object.assign({},...s);l.__metadata.version=`${Math.min(...s.map(t=>parseInt(t.__metadata.version??0)))}`,l.__metadata.cacheKey="merged";for(let[t,i]of Object.entries(l))typeof i=="string"&&delete l[t];return await u.xfs.changeFilePromise(f,(0,k.stringifySyml)(l),{automaticNewlines:!0}),!0}var L=async(e,{cwd:o})=>{let c=await r.Configuration.find(o,(0,E.getPluginConfiguration)()),f=await r.Cache.find(c),{project:n,workspace:p}=await r.Project.find(c,o);n.originalPackages=new Map(e.originalPackages),n.storedResolutions=new Map(e.storedResolutions);let s=new Set([p]);for(let l of s)for(let t of r.Manifest.hardDependencies)for(let i of l.manifest.getForScope(t).values()){let d=n.tryWorkspaceByDescriptor(i);d!==null&&s.add(d)}return await n.resolveEverything({cache:f,report:new r.ThrowReport}),await n.fetchEverything({cache:f,report:new r.ThrowReport}),n.generateLockfile()},x=e=>`\x1B[32m${e}\x1B[0m`,M={configuration:{enableWorkspaceLockfiles:{description:"Define whether workspaces should have their own lockfile.",type:r.SettingsType.BOOLEAN,default:!0},workspaceLockfiles:{description:"List of the workspaces that need a specific lockfile",type:r.SettingsType.STRING,default:!0,isArray:!0},workspaceLockfileFilename:{description:"Name of the workspaces specific lockfile",type:r.SettingsType.STRING,default:"yarn.lock-workspace"}},hooks:{afterAllInstalled:async(e,o)=>{if(!e.configuration.values.get("enableWorkspaceLockfiles"))return;let f=e.configuration.values.get("workspaceLockfiles"),n=e.configuration.values.get("workspaceLockfileFilename"),p=Array.isArray(f)?new Set(f.map(s=>e.getWorkspaceByIdent(r.structUtils.parseIdent(s)))):new Set(e.workspaces);for(let s of p){let l=m.ppath.join(s.cwd,n),t=m.ppath.join(s.cwd,m.Filename.lockfile);await m.xfs.existsPromise(l)&&(await h({projectCwd:s.cwd,normalizeDependency:e.configuration.normalizeDependency},n,o.immutable)&&(o.report.reportInfo(r.MessageName.AUTOMERGE_SUCCESS,"Automatically fixed merge conflicts \u{1F44D}"),o.report.reportSeparator()),await m.xfs.renamePromise(l,t)),await m.xfs.writeFilePromise(t,await L(e,s)),await m.xfs.renamePromise(t,l),o.report.reportInfo(null,`${x("\u2713")} Wrote ${l}`)}}}},O=M;return S(T);})();
    return plugin;
  }
};
