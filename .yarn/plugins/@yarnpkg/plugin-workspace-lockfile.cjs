/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-workspace-lockfile",
factory: function (require) {
var plugin=(()=>{var g=Object.defineProperty;var C=Object.getOwnPropertyDescriptor;var R=Object.getOwnPropertyNames;var A=Object.prototype.hasOwnProperty;var d=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,c)=>(typeof require<"u"?require:t)[c]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')});var v=(e,t)=>{for(var c in t)g(e,c,{get:t[c],enumerable:!0})},P=(e,t,c,l)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of R(t))!A.call(e,s)&&s!==c&&g(e,s,{get:()=>t[s],enumerable:!(l=C(t,s))||l.enumerable});return e};var S=e=>P(g({},"__esModule",{value:!0}),e);var O={};v(O,{default:()=>T});var r=d("@yarnpkg/core"),h=d("@yarnpkg/cli"),w=d("@yarnpkg/fslib");var a=d("@yarnpkg/core"),u=d("@yarnpkg/fslib"),k=d("@yarnpkg/parsers"),x="<<<<<<<";async function y(e,t,c){if(!e.projectCwd)return!1;let l=u.ppath.join(e.projectCwd,t);if(!await u.xfs.existsPromise(l)||!(await u.xfs.readFilePromise(l,"utf8")).includes(x))return!1;if(c)throw new a.ReportError(a.MessageName.AUTOMERGE_IMMUTABLE,"Cannot autofix a lockfile when running an immutable install");let i=await a.execUtils.execvp("git",["rev-parse","MERGE_HEAD","HEAD"],{cwd:e.projectCwd});if(i.code!==0&&(i=await a.execUtils.execvp("git",["rev-parse","REBASE_HEAD","HEAD"],{cwd:e.projectCwd})),i.code!==0&&(i=await a.execUtils.execvp("git",["rev-parse","CHERRY_PICK_HEAD","HEAD"],{cwd:e.projectCwd})),i.code!==0)throw new a.ReportError(a.MessageName.AUTOMERGE_GIT_ERROR,"Git returned an error when trying to find the commits pertaining to the conflict");let f=await Promise.all(i.stdout.trim().split(/\n/).map(async o=>{let n=await a.execUtils.execvp("git",["show",`${o}:./${t}`],{cwd:e.projectCwd});if(n.code!==0)throw new a.ReportError(a.MessageName.AUTOMERGE_GIT_ERROR,`Git returned an error when trying to access the lockfile content in ${o}`);try{return(0,k.parseSyml)(n.stdout)}catch{throw new a.ReportError(a.MessageName.AUTOMERGE_FAILED_TO_PARSE,"A variant of the conflicting lockfile failed to parse")}}));f=f.filter(o=>!!o.__metadata);for(let o of f){if(o.__metadata.version<7)for(let n of Object.keys(o)){if(n==="__metadata")continue;let m=a.structUtils.parseDescriptor(n,!0),_=e.normalizeDependency(m),E=a.structUtils.stringifyDescriptor(_);E!==n&&(o[E]=o[n],delete o[n])}for(let n of Object.keys(o)){if(n==="__metadata")continue;let m=o[n].checksum;typeof m=="string"&&m.includes("/")||(o[n].checksum=`${o.__metadata.cacheKey}/${m}`)}}let p=Object.assign({},...f);p.__metadata.version=`${Math.min(...f.map(o=>parseInt(o.__metadata.version??0)))}`,p.__metadata.cacheKey="merged";for(let[o,n]of Object.entries(p))typeof n=="string"&&delete p[o];return await u.xfs.changeFilePromise(l,(0,k.stringifySyml)(p),{automaticNewlines:!0}),!0}var D=async(e,{cwd:t})=>{let c=await r.Configuration.find(t,(0,h.getPluginConfiguration)()),l=await r.Cache.find(c),{project:s,workspace:i}=await r.Project.find(c,t);s.originalPackages=new Map(e.originalPackages),s.storedResolutions=new Map(e.storedResolutions);let f=new Set([i]);for(let p of f)for(let o of r.Manifest.hardDependencies)for(let n of p.manifest.getForScope(o).values()){let m=s.tryWorkspaceByDescriptor(n);m!==null&&f.add(m)}return await s.resolveEverything({cache:l,report:new r.ThrowReport}),await s.fetchEverything({cache:l,report:new r.ThrowReport}),s.generateLockfile()},I=e=>`\x1B[32m${e}\x1B[0m`,M={configuration:{workspaceLockfiles:{description:"List of the workspaces that need a specific lockfile",type:r.SettingsType.STRING,default:!0,isArray:!0},workspaceLockfileFilename:{description:"Name of the workspaces specific lockfile",type:r.SettingsType.STRING,default:"yarn.lock-workspace"}},hooks:{afterAllInstalled:async(e,t)=>{let c=e.configuration.values.get("workspaceLockfiles"),l=e.configuration.values.get("workspaceLockfileFilename"),s=Array.isArray(c)?new Set(c.map(i=>e.getWorkspaceByIdent(r.structUtils.parseIdent(i)))):new Set(e.workspaces);for(let i of s){let f=w.ppath.join(i.cwd,l),p=w.ppath.join(i.cwd,w.Filename.lockfile);if(await w.xfs.existsPromise(f)){let o=await r.Configuration.find(i.cwd,(0,h.getPluginConfiguration)());t.report.reportInfo(null,o.projectCwd),await y({projectCwd:i.cwd,normalizeDependency:e.configuration.normalizeDependency},l,t.immutable)&&(t.report.reportInfo(r.MessageName.AUTOMERGE_SUCCESS,"Automatically fixed merge conflicts \u{1F44D}"),t.report.reportSeparator()),await w.xfs.renamePromise(f,p)}await w.xfs.writeFilePromise(p,await D(e,i)),await w.xfs.renamePromise(p,f),t.report.reportInfo(null,`${I("\u2713")} Wrote ${f}`)}}}},T=M;return S(O);})();
return plugin;
}
};
