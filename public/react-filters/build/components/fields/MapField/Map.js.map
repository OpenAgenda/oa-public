{"version":3,"sources":["../../../../src/components/fields/MapField/Map.js"],"sourcesContent":["import React, {\n  useCallback,\n  useContext,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport cn from 'classnames';\nimport {\n  MapContainer,\n  Marker,\n  TileLayer,\n  useMapEvents,\n  useMap,\n} from 'react-leaflet';\nimport L from 'leaflet';\nimport { useIntl } from 'react-intl';\nimport '@openagenda/leaflet-gesture-handling';\nimport { useForm } from 'react-final-form';\nimport FiltersAndWidgetsContext from '../../../contexts/FiltersAndWidgetsContext.js';\nimport SearchHereControl from './SearchHereControl.js';\n\nconst padRatio = 0.2;\nconst unpadRatio = -(1 / ((1 + padRatio + padRatio) / padRatio));\n\nconst worldViewport = {\n  bottomRight: {\n    latitude: -90,\n    longitude: 180,\n  },\n  topLeft: {\n    latitude: 90,\n    longitude: -180,\n  },\n};\n\nfunction loadGestureHandlingLocale(gestureHandling, locale) {\n  import(`@openagenda/leaflet-gesture-handling/dist/locales/${locale}.js`)\n    .then((m) => {\n      const content = m.default || m;\n      const scrollWarning = gestureHandling._isMacUser()\n        ? content.scrollMac\n        : content.scroll;\n      gestureHandling._map._container.setAttribute(\n        'data-gesture-handling-touch-content',\n        content.touch,\n      );\n      gestureHandling._map._container.setAttribute(\n        'data-gesture-handling-scroll-content',\n        scrollWarning,\n      );\n      gestureHandling._touchWarning = content.touch;\n      gestureHandling._scrollWarning = scrollWarning;\n    })\n    .catch((e) => {\n      console.log(`Cannot load gestureHandling locale \"${locale}\"`, e);\n    });\n}\n\nfunction waitMapBounds(map, interval = 16) {\n  return new Promise((resolve, _reject) => {\n    const attemptGetBounds = () => {\n      try {\n        const bounds = map.getBounds();\n        if (bounds) {\n          resolve(bounds);\n        } else {\n          throw new Error('Bounds not available');\n        }\n      } catch (error) {\n        setTimeout(attemptGetBounds, interval);\n      }\n    };\n\n    setTimeout(() => attemptGetBounds());\n  });\n}\n\nfunction valueToViewport(value) {\n  const bounds = new L.LatLngBounds(\n    new L.LatLng(value.northEast.lat, value.northEast.lng),\n    new L.LatLng(value.southWest.lat, value.southWest.lng),\n  );\n\n  const southEast = bounds.getSouthEast();\n  const northWest = bounds.getNorthWest();\n\n  return {\n    bottomRight: {\n      latitude: southEast.lat,\n      longitude: southEast.lng,\n    },\n    topLeft: {\n      latitude: northWest.lat,\n      longitude: northWest.lng,\n    },\n  };\n}\n\nfunction viewportToBounds(viewport) {\n  return new L.LatLngBounds(\n    new L.LatLng(viewport.bottomRight.latitude, viewport.bottomRight.longitude),\n    new L.LatLng(viewport.topLeft.latitude, viewport.topLeft.longitude),\n  );\n}\n\nfunction isEqualBounds(a, b) {\n  return (\n    String(a?.northEast?.lat) === String(b?.northEast?.lat)\n    && String(a?.northEast?.lng) === String(b?.northEast?.lng)\n    && String(a?.southWest?.lat) === String(b?.southWest?.lat)\n    && String(a?.southWest?.lng) === String(b?.southWest?.lng)\n  );\n}\n\n/*\nReturns bounds created by extending or retracting the current bounds by a given ratio in each direction.\nFor example, a ratio of 0.5 extends the bounds by 50% in each direction.\nNegative values will retract the bounds.\nSkip the padding if the whole map is seen.\n*/\nfunction normalizeBounds(bounds, bufferRatio = 1) {\n  const sw = bounds.getSouthWest();\n  const ne = bounds.getNorthEast();\n  const height = Math.abs(sw.lat - ne.lat); // 85 * 2 is the whole map\n  const width = Math.abs(sw.lng - ne.lng); // 180 * 2 is the whole map\n  const heightBuffer = height * bufferRatio;\n  const widthBuffer = Math.min(width, 360) * bufferRatio;\n\n  // For positive pad\n  const south = height > 170 ? sw.lat : sw.lat - heightBuffer;\n  const west = width > 360 ? -180 : sw.lng - widthBuffer;\n  const north = height > 170 ? ne.lat : ne.lat + heightBuffer;\n  const east = width > 360 ? 180 : ne.lng + widthBuffer;\n\n  return new L.LatLngBounds(\n    new L.LatLng(south, west),\n    new L.LatLng(north, east),\n  );\n}\n\nfunction convertToKFormat(intl, number) {\n  if (number >= 1000) {\n    return `${intl.formatNumber((number / 1000).toFixed(1))}k`;\n  }\n\n  return number.toString();\n}\n\nfunction MarkerClusterIcon({ latitude, longitude, eventCount }) {\n  const intl = useIntl();\n  const map = useMap();\n  const position = useMemo(() => [latitude, longitude], [latitude, longitude]);\n  const icon = useMemo(\n    () =>\n      new L.DivIcon({\n        html: `<div style=\"pointer-events: none;\"><span>${convertToKFormat(intl, eventCount)}</span></div>`,\n        className: cn('marker-cluster leaflet-interactive', {\n          'marker-cluster-small': eventCount < 10,\n          'marker-cluster-medium': eventCount < 100,\n          'marker-cluster-large': eventCount >= 100,\n        }),\n        iconSize: new L.Point(40, 40),\n      }),\n    [eventCount],\n  );\n\n  return (\n    <Marker\n      position={position}\n      icon={icon}\n      eventHandlers={{\n        click: () => {\n          map.setView(position, Math.min(map.getZoom() + 1, map.getMaxZoom()));\n        },\n      }}\n    />\n  );\n}\n\nfunction OnMapMove({ onChange }) {\n  useMapEvents({\n    moveend() {\n      onChange();\n    },\n  });\n\n  return null;\n}\n\nconst Map = React.forwardRef(\n  (\n    {\n      input,\n      tileAttribution,\n      tileUrl,\n      loadGeoData,\n      initialViewport,\n      defaultViewport,\n      className,\n      searchHereControl: SearchHereControlComponent = SearchHereControl,\n    },\n    ref,\n  ) => {\n    const intl = useIntl();\n    const form = useForm();\n\n    const {\n      filtersOptions: { manualSubmit },\n    } = useContext(FiltersAndWidgetsContext);\n\n    const mapRef = useRef();\n    const programmaticMoveRef = useRef(false);\n\n    const [viewport] = useState(() =>\n      (input.value ? valueToViewport(input.value) : initialViewport));\n\n    const skipMoveRef = useRef(true);\n\n    const [data, setData] = useState(() => []);\n\n    const [displayedMarkers, setDisplayedMarkers] = useState(false);\n    const [bounds] = useState(() =>\n      viewportToBounds(viewport || defaultViewport || worldViewport).pad(\n        padRatio,\n      ));\n    useImperativeHandle(ref, () => ({\n      setData,\n      onQueryChange: (newViewport) => {\n        const map = mapRef.current;\n\n        function reloadData() {\n          waitMapBounds(map).then((bounds1) => {\n            const innerBounds = normalizeBounds(bounds1, unpadRatio);\n            const innerZoom = map.getBoundsZoom(bounds1);\n\n            loadGeoData(innerBounds, innerZoom)\n              .then((newData) => setData(newData?.reverse() ?? []))\n              .catch((err) => {\n                console.log('Failed to load geo data', err);\n              });\n          });\n        }\n\n        if (!skipMoveRef.current) {\n          map.once('moveend', () => reloadData());\n          programmaticMoveRef.current = true;\n          map.fitBounds(\n            viewportToBounds(\n              newViewport || defaultViewport || worldViewport,\n            ).pad(padRatio),\n          );\n        } else {\n          reloadData();\n        }\n        skipMoveRef.current = false;\n      },\n    }));\n\n    const onMapReady = useCallback(\n      ({ target: map }) => {\n        mapRef.current = map;\n\n        loadGestureHandlingLocale(map.gestureHandling, intl.locale);\n\n        // Remove flag\n        map.attributionControl.setPrefix(\n          '<a href=\"https://leafletjs.com\" title=\"A JavaScript library for interactive maps\">Leaflet</a>',\n        );\n\n        waitMapBounds(map).then((bounds1) => {\n          const innerBounds = normalizeBounds(bounds1, unpadRatio);\n          const innerZoom = map.getBoundsZoom(bounds1);\n\n          loadGeoData(innerBounds, innerZoom)\n            .then((newData) => {\n              setData(newData?.reverse() ?? []);\n              setDisplayedMarkers(true);\n            })\n            .catch((err) => {\n              console.log('Failed to load geo data', err);\n            })\n            .finally(() => {\n              skipMoveRef.current = false;\n            });\n        });\n      },\n      [bounds, loadGeoData],\n    );\n\n    const searchHere = useCallback(\n      (e) => {\n        e.preventDefault();\n\n        const map = mapRef.current;\n\n        if (!map) return;\n\n        skipMoveRef.current = true;\n\n        const innerBounds = normalizeBounds(map.getBounds(), unpadRatio);\n        const northEast = innerBounds.getNorthEast().wrap();\n        const southWest = innerBounds.getSouthWest().wrap();\n\n        input.onChange({\n          northEast: {\n            lat: String(northEast.lat),\n            lng: String(northEast.lng),\n          },\n          southWest: {\n            lat: String(southWest.lat),\n            lng: String(southWest.lng),\n          },\n        });\n\n        if (manualSubmit) {\n          form.submit();\n        }\n      },\n      [input, mapRef],\n    );\n\n    const [latestBounds, setLatestBounds] = useState(false);\n\n    const onChange = useCallback(() => {\n      const map = mapRef.current;\n\n      const bounds1 = map.getBounds();\n      const innerBounds = normalizeBounds(bounds1, unpadRatio);\n      const innerZoom = map.getBoundsZoom(bounds1);\n\n      setLatestBounds(innerBounds);\n\n      if (programmaticMoveRef.current) {\n        programmaticMoveRef.current = false;\n        return;\n      }\n\n      const { current: mapElem } = ref;\n      loadGeoData(innerBounds, innerZoom)\n        .then((data1) => mapElem.setData(data1?.reverse() ?? []))\n        .catch((err) => {\n          console.log('Failed to geo data', err);\n        });\n    }, [loadGeoData, ref]);\n\n    const disabledMapSearch = useMemo(\n      () =>\n        !latestBounds\n        || isEqualBounds(input.value, {\n          northEast: latestBounds.getNorthEast().wrap(),\n          southWest: latestBounds.getSouthWest().wrap(),\n        }),\n      [input.value, latestBounds],\n    );\n\n    const gestureHandlingOptions = useMemo(\n      () => ({\n        locale: intl.locale,\n      }),\n      [intl.locale],\n    );\n\n    return (\n      <>\n        <MapContainer\n          className={className}\n          bounds={bounds}\n          whenReady={onMapReady}\n          // scrollWheelZoom={false}\n          gestureHandling\n          gestureHandlingOptions={gestureHandlingOptions}\n          doubleClickZoom\n          worldCopyJump\n          // minZoom={1}\n        >\n          <TileLayer attribution={tileAttribution} url={tileUrl} />\n\n          {displayedMarkers\n            ? data.map((entry) => (\n              <MarkerClusterIcon\n                key={entry.key}\n                eventCount={entry.eventCount}\n                latitude={entry.latitude}\n                longitude={entry.longitude}\n              />\n            ))\n            : null}\n\n          <OnMapMove onChange={onChange} />\n        </MapContainer>\n\n        {!disabledMapSearch ? (\n          <SearchHereControlComponent searchHere={searchHere} />\n        ) : null}\n      </>\n    );\n  },\n);\n\nexport default Map;\n"],"mappings":"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","names":[]}